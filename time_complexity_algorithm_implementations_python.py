# -*- coding: utf-8 -*-
"""time-complexity-algorithm-implementations-python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14hyagJGNLSea9WOH2syoYljVa8b5ht0o
"""

# Algorithm 1: Constant Time (O(1))
def constant_time_algo():
    """
    This function represents an algorithm with constant running time O(1).
    It performs a simple operation that takes a constant amount of time
    regardless of the input size.
    """
    print("This is a constant time algorithm!")

# Algorithm 2: Logarithmic Time (O(logN))
def logarithmic_time_algo(n):
    """
    This function represents an algorithm with logarithmic running time O(logN).
    It performs a binary search on a sorted list of size N.

    :param n: The size of the list on which the binary search is performed.
    """
    low = 0
    high = n - 1
    target = 42  # Target element to search for
    while low <= high:
        mid = (low + high) // 2
        if target == mid:
            print("Found target element!")
            return
        elif target < mid:
            high = mid - 1
        else:
            low = mid + 1
    print("Target element not found!")

# Algorithm 3: Linear Time (O(N))
def linear_time_algo(arr):
    """
    This function represents an algorithm with linear running time O(N).
    It performs a simple operation on each element of the input array.

    :param arr: The input array of size N.
    """
    for num in arr:
        # Replace the following line with the desired operation
        print(num)

# Algorithm 4: N Log N Time (O(N log N))
def nlogn_time_algo(arr):
    """
    This function represents an algorithm with N log N running time O(N log N).
    It sorts the input array using a sorting algorithm with O(N log N) complexity.

    :param arr: The input array of size N.
    """
    sorted_arr = sorted(arr)
    print("Sorted array:", sorted_arr)

# Algorithm 5: Quadratic Time (O(N^2))
def quadratic_time_algo(n):
    """
    This function represents an algorithm with quadratic running time O(N^2).
    It performs nested loops where the inner loop depends on the size of N.

    :param n: The size of the loop iterations.
    """
    for i in range(n):
        for j in range(n):
            # Replace the following line with the desired operation
            print(i, j)

# Algorithm 6: Cubic Time (O(N^3))
def cubic_time_algo(n):
    """
    This function represents an algorithm with cubic running time O(N^3).
    It performs three nested loops where each loop depends on the size of N.

    :param n: The size of the loop iterations.
    """
    for i in range(n):
        for j in range(n):
            for k in range(n):
                # Replace the following line with the desired operation
                print(i, j, k)

# Algorithm 7: Polynomial Time (O(N^K))
def polynomial_time_algo(n, k):
    """
    This function represents an algorithm with polynomial running time O(N^K).
    It performs a loop that depends on the size of N raised to the power of K.

    :param n: The size of the loop iterations.
    :param k: The power of N in the polynomial.
    """
    for i in range(n ** k):
        # Replace the following line with the desired operation
        print(i)

# Algorithm 8: Exponential Time (O(2^N))
def exponential_time_algo(n):
    """
    This function represents an algorithm with exponential running time O(2^N).
    It performs a recursive operation with a branching factor of 2.

    :param n: The input size for the recursive operation.
    """
    if n <= 0:
        return
    exponential_time_algo(n - 1)
    exponential_time_algo(n - 1)

# Testing the algorithms
if __name__ == "__main__":
    constant_time_algo()
    logarithmic_time_algo(16)
    linear_time_algo([1, 2, 3, 4, 5])
    nlogn_time_algo([5, 3, 1, 4, 2])
    quadratic_time_algo(3)
    cubic_time_algo(2)
    polynomial_time_algo(2, 3)
    exponential_time_algo(3)